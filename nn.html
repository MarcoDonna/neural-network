<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <canvas id="initial" width="1200" height="600" style="border:1px dashed red"></canvas>
    <canvas id="final" width="1200" height="600" style="border:1px dashed red"></canvas>
    <script>

const networkDebugger = (nn, canvas) => {
            canvas.font = "10px Arial";
            const LEFT_MARGIN = 45,
                TOP_MARGIN = 45,
                NEURON_RADIUS = 40,
                NEURON_PADDING_X = 220,
                NEURON_PADDING_Y = 70;
            for(let i = 0; i < nn.layers.length; i++)
                for(let j = 0; j < nn.layers[i].neurons.length; j++){
                    const neuron = nn.layers[i].neurons[j];
                    const left = LEFT_MARGIN + i * (NEURON_PADDING_X + NEURON_RADIUS);
                    const top = TOP_MARGIN + j * (NEURON_PADDING_Y + NEURON_RADIUS);

                    
                    canvas.beginPath();
                    canvas.strokeStyle = `rgb(0, 0, 0)`;
                    canvas.arc(left, top, NEURON_RADIUS, 1/2*Math.PI, 3/2*Math.PI);
                    canvas.arc(left, top, NEURON_RADIUS, 1/2*Math.PI, 3/2*Math.PI, true);
                    canvas.stroke();

                    const red = 255 * (neuron.weights[0] + 1) / 2;
                    const blue = 255 - 255 * (neuron.weights[0] + 1) / 2;
                    
                    canvas.fillStyle = `rgb(${red}, 0, ${blue})`;
                    canvas.fillText(neuron.weights[0].toFixed(3), left-NEURON_RADIUS+5, top-5);
                    canvas.fillStyle = `rgb(0, 0, 0)`;
                    if(neuron.h !== undefined && neuron.o !== undefined){
                        canvas.fillText(neuron.h.toFixed(3), left-NEURON_RADIUS+5, top+5);
                        canvas.fillText(neuron.o.toFixed(3), left+5, top);
                        if(nn.layers[i].error !== undefined)
                            canvas.fillText(nn.layers[i].error[j].toFixed(6), left-20, top+NEURON_RADIUS+10)
                    }
                    
                    

                    if(i != 0){
                        for(let k = 0; k < nn.layers[i-1].neurons.length; k++){
                            //Loop each neuron in prev layer
                            canvas.beginPath();
                            const red = 255 * (neuron.weights[k+1] + 1) / 2;
                            const blue = 255 - 255 * (neuron.weights[k+1] + 1) / 2;
                            canvas.moveTo(left - NEURON_RADIUS, top);
                            canvas.lineTo(LEFT_MARGIN + (i-1) * (NEURON_PADDING_X + NEURON_RADIUS) + NEURON_RADIUS, TOP_MARGIN + k * (NEURON_PADDING_Y + NEURON_RADIUS));
                            canvas.strokeStyle = `rgb(${red}, 0, ${blue})`;
                            canvas.stroke();
                        }
                    }

                }
        }
        
        class ReLU{
            static f(x){
                return x > 0 ? x : 0;
            }

            static d(x){
                return x > 0 ? 1 : 0;
            }
        }

        class Sigmoid{
            static f(x){
                return 1 / (1 + Math.exp(-x));
            }

            static d(x){
                return this.f(x) * (1 - this.f(x));
            }
        }

        class Linear{
            static f(x){return x}
            static d(x){return 1}
        }

        class Neuron{
            constructor(inputSize){
                this.weights = [Math.random()]; //Weights[0] is bias
                for(let i = 0; i < inputSize; i++)
                    this.weights.push(Math.random() * 2 - 1); //One weight for each input
            }

            forward(inputVector, activation){
                this.h = this.weights[0];
                for(let i = 1; i < this.weights.length; i++)
                    this.h += inputVector[i-1] * this.weights[i]; //Product sum plus bias
                this.o = activation.f(this.h); //Node output
                return this;
            }
        }

        class Layer{
            constructor(neurons, inputs, activation){
                this.neurons = [];
                this.activation = activation;

                for(let i = 0; i < neurons; i++)
                    this.neurons.push(new Neuron(inputs));
            }

            forward(input){
                for(let i = 0; i < this.neurons.length; i++)
                    this.neurons[i].forward(input, this.activation);
            }
        }

        class OutputLayer extends Layer{
            constructor(neurons, inputs, activation){
                super(neurons, inputs, activation);
            }
        }

        class InputLayer extends Layer{
            constructor(inputs){
                super(inputs, 1, Linear);

                for(let i = 0; i < this.neurons.length; i++)
                    for(let j = 0; j < this.neurons[i].weights.length; j++)
                        //Initialize weight to 1, bias to 0 with linear activation function to pass inputs without any transformation
                        if(j == 0)
                            this.neurons[i].weights[j] = 0;
                        else
                            this.neurons[i].weights[j] = 1;
            }

            forward(inputs){
                for(let i = 0; i < this.neurons.length; i++)
                    this.neurons[i].forward([inputs[i]], this.activation);
            }
        }

        class NeuralNetwork{
            constructor(shape){
                this.layers = [];                
                this.layers.push(new InputLayer(shape[0]));
                for(let i = 1; i < shape.length-1; i++)
                    this.layers.push(new Layer(shape[i], shape[i-1], ReLU))
                this.layers.push(new OutputLayer(shape[shape.length-1], shape[shape.length-2], ReLU));                    
            }

            forward(inputVector){
                let layerOutput = inputVector;
                for(let i = 0; i < this.layers.length; i++){
                    //Prev layer output becomes input
                    this.layers[i].forward(layerOutput);
                    layerOutput = this.layers[i].neurons.map(neuron => neuron.o);                    
                }
                this.out = layerOutput;
                return this;
            }

            train(predictors, classes){
                let epochs = 10000;
                let learningRate = 0.1;
                /*
                https://brilliant.org/wiki/backpropagation/
                https://brilliant.org/wiki/feedforward-neural-networks/
                */
                
                for(let e = 0; e < epochs; e++){
                    for(let recordIdx = 0; recordIdx < predictors.length; recordIdx++){
                        //Feedforward
                        this.forward(predictors[recordIdx]);

                        //Last layer error
                        const lastLayer = this.layers[this.layers.length-1];
                        lastLayer.error = [];
                        for(let i = 0; i < lastLayer.neurons.length; i++){ //lastLayer.neurons.length same as classes[recordIdx].length
                            const neuron = lastLayer.neurons[i];
                            const error = lastLayer.activation.d(neuron.h) * (neuron.o - classes[recordIdx][i]);
                            lastLayer.error.push(error);
                        }

                        //Hidden layers error
                        for(let i = this.layers.length-2; i > 0; i--){
                            const layer = this.layers[i];
                            const nextLayer = this.layers[i+1];

                            layer.error = [];
                            for(let j = 0; j < layer.neurons.length; j++){
                                const neuron = layer.neurons[j];
                                let error = layer.activation.d(neuron.h);
                                let s = 0;

                                for(let k = 0; k < nextLayer.neurons.length; k++){                                    
                                    const nextLayerNeuron = nextLayer.neurons[k];
                                    s += nextLayerNeuron.weights[j+1] * nextLayer.error[k]; 
                                }
                                layer.error.push(error * s);
                            }                            
                        }
                    } 
                }
            }
        }

        let nn = new NeuralNetwork([2, 2, 1]);

        /*XOR Data*/
        const d = [
            {X: [0, 0], Y: [0]},
            {X: [0, 1], Y: [1]},
            {X: [1, 0], Y: [1]},
            {X: [1, 1], Y: [0]},
        ]

        const predictors = d.map(record => record.X);
        const classes = d.map(record => record.Y);


        let canvas = document.getElementById("initial").getContext("2d");
        let canvas2 = document.getElementById("final").getContext("2d");
        networkDebugger(nn, canvas);
        nn.train(predictors, classes);
        networkDebugger(nn, canvas2);

        for(let i = 0; i < d.length; i++){
            console.log(`predicted: ${nn.forward(d[i].X).out}, expexted: ${d[i].Y}`)
        }

        
    </script>
</body>
</html>