<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <canvas id="debugger" width="1200" height="600" style="border:1px dashed red"></canvas>
    <script>
        
        class ReLU{
            static f(x){
                return x > 0 ? x : 0;
            }

            static d(x){
                return x > 0 ? 1 : 0;
            }
        }

        class Sigmoid{
            static f(x){
                return 1 / (1 + Math.exp(-x));
            }

            static d(x){
                return this.f(x) * (1 - this.f(x));
            }
        }

        class Linear{
            static f(x){return x}
            static d(x){return 1}
        }

        class Neuron{
            constructor(inputSize){
                this.weights = [Math.random() * 2 - 1]; //Weights[0] is bias
                for(let i = 0; i < inputSize; i++)
                    this.weights.push(Math.random() * 2 - 1); //One weight for each input
            }

            forward(inputVector, activation){
                this.h = this.weights[0];
                for(let i = 1; i < this.weights.length; i++)
                    this.h += inputVector[i-1] * this.weights[i]; //Product sum plus bias
                this.o = activation.f(this.h); //Node output
                return this;
            }
        }

        class Layer{
            constructor(neurons, inputs, activation){
                this.neurons = [];
                this.activation = activation;

                for(let i = 0; i < neurons; i++)
                    this.neurons.push(new Neuron(inputs));
            }

            forward(input){
                for(let i = 0; i < this.neurons.length; i++)
                    this.neurons[i].forward(input, this.activation);
            }
        }

        class OutputLayer extends Layer{
            constructor(neurons, inputs, activation){
                super(neurons, inputs, activation);
            }
        }

        class InputLayer extends Layer{
            constructor(inputs){
                super(inputs, 1, Linear);

                for(let i = 0; i < this.neurons.length; i++)
                    for(let j = 0; j < this.neurons[i].weights.length; j++)
                        //Initialize weight to 1, bias to 0 with linear activation function to pass inputs without any transformation
                        if(j == 0)
                            this.neurons[i].weights[j] = 0;
                        else
                            this.neurons[i].weights[j] = 1;
            }

            forward(inputs){
                for(let i = 0; i < this.neurons.length; i++)
                    this.neurons[i].forward([inputs[i]], this.activation);
            }
        }

        class NeuralNetwork{
            constructor(shape){
                this.layers = [];                
                this.layers.push(new InputLayer(shape[0]));
                for(let i = 1; i < shape.length-1; i++)
                    this.layers.push(new Layer(shape[i], shape[i-1], ReLU))
                this.layers.push(new OutputLayer(shape[shape.length-1], shape[shape.length-2], ReLU));                    
            }

            forward(inputVector){
                let layerOutput = inputVector;
                for(let i = 0; i < this.layers.length; i++){
                    //Prev layer output becomes input
                    this.layers[i].forward(layerOutput);
                    layerOutput = this.layers[i].neurons.map(neuron => neuron.o);                    
                }
                this.out = layerOutput;
                return this;
            }
        }

        let nn = new NeuralNetwork([2, 4, 4, 1]);

        nn.forward([1, 0]);

        let canvas = document.getElementById("debugger").getContext("2d");
        canvas.font = "10px Arial";

        const networkDebugger = nn => {
            const LEFT_MARGIN = 45,
                TOP_MARGIN = 45,
                NEURON_RADIUS = 40,
                NEURON_PADDING_X = 200,
                NEURON_PADDING_Y = 50;
            for(let i = 0; i < nn.layers.length; i++)
                for(let j = 0; j < nn.layers[i].neurons.length; j++){
                    const neuron = nn.layers[i].neurons[j];
                    const left = LEFT_MARGIN + i * (NEURON_PADDING_X + NEURON_RADIUS);
                    const top = TOP_MARGIN + j * (NEURON_PADDING_Y + NEURON_RADIUS);

                    
                    canvas.beginPath();
                    canvas.strokeStyle = `rgb(0, 0, 0)`;
                    canvas.arc(left, top, NEURON_RADIUS, 1/2*Math.PI, 3/2*Math.PI);
                    canvas.arc(left, top, NEURON_RADIUS, 1/2*Math.PI, 3/2*Math.PI, true);
                    canvas.stroke();

                    const red = 255 * (neuron.weights[0] + 1) / 2;
                    const blue = 255 - 255 * (neuron.weights[0] + 1) / 2;
                    
                    canvas.fillStyle = `rgb(${red}, 0, ${blue})`;
                    canvas.fillText(neuron.weights[0].toFixed(3), left-NEURON_RADIUS+5, top-5);
                    canvas.fillStyle = `rgb(0, 0, 0)`;
                    canvas.fillText(neuron.h.toFixed(3), left-NEURON_RADIUS+5, top+5);
                    canvas.fillText(neuron.o.toFixed(3), left+5, top);
                    

                    if(i != 0){
                        for(let k = 0; k < nn.layers[i-1].neurons.length; k++){
                            //Loop each neuron in prev layer
                            canvas.beginPath();
                            const red = 255 * (neuron.weights[k+1] + 1) / 2;
                            const blue = 255 - 255 * (neuron.weights[k+1] + 1) / 2;
                            canvas.moveTo(left - NEURON_RADIUS, top);
                            canvas.lineTo(LEFT_MARGIN + (i-1) * (NEURON_PADDING_X + NEURON_RADIUS) + NEURON_RADIUS, TOP_MARGIN + k * (NEURON_PADDING_Y + NEURON_RADIUS));
                            canvas.strokeStyle = `rgb(${red}, 0, ${blue})`;
                            canvas.stroke();
                        }
                    }

                }
        }

        networkDebugger(nn);
    </script>
</body>
</html>