<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Self Driving</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.2/jquery.min.js" integrity="sha512-tWHlutFnuG0C6nQRlpvrEhE4QpkG1nn2MOUMWmUeRePl4e3Aki0VB6W1v3oLjFtd0hVOtRQ9PHpSfN6u6/QXkQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js" integrity="sha512-WJXVjqeINVpi5XXJ2jn0BSCfp0y80IKrYh731gLRnkAS9TKc5KNt/OfLtu+fCueqdWniouJ1ubM+VI/hbo7POQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <script src="activationFunctions.js"></script>
    <script src="neuralNetwork.js"></script>

    <style>
        body{
            padding: 10px;
        }

        #environment{
            width: 100%;
            height: 70vh;
            border: 1px solid black
        }
    </style>

</head>
<body>
    <h1>Self Driving Car With Neural Network</h1>
    <h3>Press UP_ARROW to start/stop the car, LEFT_ARROW and RIGHT_ARROW to steer, R to reverse direction</h3>
    <h3>Press SPACE to stop the car, train the model on engage autopilot</h3>
    <label for="raycasts">Show Raycasts</label>
    <input type="checkbox" id="raycasts">
    <label for="skip-training">Skip Training (load saved model)</label>
    <input type="checkbox" id="skip-training">
    <button id="model-save">Save Model</button>
    <div id="environment"></div>
    <script>

        class Environment{
            constructor(map, obstacles, cars){
                this.map = map || [];
                this.obstacles = obstacles || [];
                for(let i = 0; i < this.obstacles.length; i++){
                    const o = obstacles[i];
                    map.push([o[0], o[1], o[0] + o[2], o[1]]);
                    map.push([o[0], o[1], o[0], o[1] + o[3]]);
                    map.push([o[0] + o[2], o[1] + o[3], o[0] + o[2], o[1]]);
                    map.push([o[0] + o[2], o[1] + o[3], o[0], o[1] + o[3]]);
                }
            }

            render(p){
                //Render Map
                for(let i = 0; i < mapWalls.length; i++)
                    p.line(...mapWalls[i]);
            }
        }

        class Car{
            constructor(par){
                this.x = par.x || 0;
                this.y = par.y || 0;
                this.on = true;
                this.width = par.width || 20;
                this.height = par.height || 30;
                this.angle = par.angle || 0;
                this.color = par.color || [255, 0, 0];
                this.immortal = false;
                this.alive = true;
                this.turn = 0.02;
                this.speed = 1;

                this.autopilot = {on: false, model: new NeuralNetwork([3, 4, 4, 2])}

                this.raycast = [];
                this.perimeter = [];
            }

            setPerimeter(p){
                this.perimeter = [[this.x - this.height/2, this.y - this.width/2, this.x + this.height/2, this.y - this.width/2],
                                [this.x - this.height/2, this.y - this.width/2, this.x - this.height/2, this.y + this.width/2],
                                [this.x + this.height/2, this.y + this.width/2, this.x - this.height/2, this.y + this.width/2],
                                [this.x + this.height/2, this.y + this.width/2, this.x + this.height/2, this.y - this.width/2]]
                return this;
            }

            move(m){
                m = m || 1;
                this.x -= (this.on ? 1 : 0) * Math.sin(this.angle) * this.speed * m;
                this.y += (this.on ? 1 : 0) * Math.cos(this.angle) * this.speed * m;
                return this;
            }

            control(l, r){
                this.angle += (this.on == true ? 1 : 0) * l * this.turn;
                this.angle -= (this.on == true ? 1 : 0) * r * this.turn;
                return this;
            }

            distance(env, cars){
                if(!cars)
                    cars = [];
                const rays = [                    
                    [this.x - Math.sin(this.angle-0.3) * 150, this.y + Math.cos(this.angle-0.3) * 150],
                    [this.x - Math.sin(this.angle) * 150, this.y + Math.cos(this.angle) * 150],                    
                    [this.x - Math.sin(this.angle+0.3) * 150, this.y + Math.cos(this.angle+0.3) * 150]
                ]
                let rayData = [];
                for(let i = 0; i < rays.length; i++){
                    let rayMapInterceptPoints = [];
                    for(let j = 0; j < env.map.length; j++)                   
                        rayMapInterceptPoints.push(intercept([this.x, this.y], rays[i], [env.map[j][0], env.map[j][1]], [env.map[j][2], env.map[j][3]]))
                    
                    for(let j = 0; j < cars.length; j++)
                        for(let k = 0; k < cars[j].perimeter.length; k++)
                            rayMapInterceptPoints.push(intercept([this.x, this.y], rays[i], [cars[j].perimeter[k][0], cars[j].perimeter[k][1]], [cars[j].perimeter[k][2], cars[j].perimeter[k][3]]))
                    rayData.push(closest([this.x, this.y], rayMapInterceptPoints.map(point => point === Infinity ? rays[i] : point)));
                }
                this.raycast = rayData;
                return this;
            }

            aliveStatus(){
                for(let i = 0; i < this.raycast.length; i++)
                    if(euclideanDistance([this.x, this.y], this.raycast[i]) < Math.max(this.height/2, this.width/2) && this.immortal == false){
                        this.alive = false;
                        if(this.onDeath)
                                this.onDeath(this);
                    }
                return this;
            }

            render(p){
                //Render Car
                p.translate(this.x, this.y);
                p.rotate(this.angle);
                p.rect(-this.width / 2, -this.height / 2, this.width, this.height);
                p.rect(-1, -1, 1, 1);                
                p.rotate(-this.angle);
                p.translate(-this.x, -this.y);                
                for(let i = 0; i < this.raycast.length; i++){
                    p.line(this.x, this.y, ...this.raycast[i]);
                    p.ellipse(this.raycast[i][0], this.raycast[i][1], 4, 4);                    
                }
                return this;
            }
        }

        $("#model-save").on("click", ev => {
            localStorage.setItem("car-model", JSON.stringify(environment.car.autopilot.model.export()));
        });

        let mapWalls = [
            //Outer walls
            [100, 10, 700, 10],      
            [700, 10, 800, 100],
            [800, 100, 900, 100],
            [900, 100, 1000, 10],
            [1000, 10, 1200, 10],
            [1200, 10, 1300, 100],
            [1300, 100, 1300, 500],
            [1300, 500, 1100, 600],
            [1100, 600, 100, 600],
            [100, 600, 10, 500],
            [10, 500, 10, 100],
            [10, 100, 100, 10],


            //Inner walls
            [150, 100, 650, 100],
            [650, 100, 800, 200],
            [800, 200, 900, 200],
            [900, 200, 1050, 100],
            [1050, 100, 1150, 100],
            [1150, 100, 1200, 150],
            [1150, 100, 1200, 150],
            [1200, 150, 1200, 430],
            [1200, 430, 1050, 500],
            [1050, 500, 150, 500],
            [150, 500, 100, 450],
            [100, 450, 100, 150],
            [100, 150, 150, 100]
        ];
            
        let trainingdataset = []

        const del = () => localStorage.removeItem("car-model");

        const euclideanDistance = (a, b) => {
            let dist = 0;
            for(let i = 0; i < a.length; i++)
                dist += Math.pow(b[i] - a[i], 2);
            return Math.sqrt(dist);
        }

        const closest =  (a, b) => {
                let closest = b[0];
                let minDist = euclideanDistance(a, b[0]);
                for(let i = 1; i < b.length; i++){
                    const dist = euclideanDistance(a, b[i])
                    if(dist < minDist){
                        minDist = dist;
                        closest = b[i];
                    }
                }
                return closest;
            }

        const intercept = (a, b, c, d) => {
            const p = a;
            const r = p.map((item, index) => b[index] - item);
            const q = c;
            const s = q.map((item, index) => d[index] - item);

            const RxS = r[0] * s[1] - r[1] * s[0];
            const u = ((q[0] - p[0]) * r[1] - (q[1] - p[1]) * r[0]) / RxS;
            const t = ((q[0] - p[0]) * s[1] - (q[1] - p[1]) * s[0]) / RxS;

            if(RxS != 0 && u >= 0 && u <= 1 && t >= 0 && t <= 1)
                return [p[0] + t * r[0], p[1] + t * r[1]];
            return Infinity;
        }

        const sketch = p => {

            p.cars = [];
            p.map = new Environment(mapWalls);

            p.setup = () => {
                p.frameRate(60);
                p.createCanvas($("#environment").width(), $("#environment").height());  
                p.cars.push(new Car({x: 100, y: 50, angle: -Math.PI/2}));
                p.cars[0].onDeath = c => {c.x = 100, c.y = 50, c.angle = -Math.PI/2, c.alive = true};  
            }

            p.draw = () => {                
                p.background(255);
                p.map.render(p);
                p.cars.forEach((car, index) => {
                    const otherCars = p.cars.filter((car, _index) => index != _index)
                    car.move(1);
                    car.setPerimeter();
                    car.aliveStatus();
                    car.distance(p.map, otherCars);
                    if(car.autopilot.on){
                        const action = car.autopilot.model.forward(car.raycast).out.map(a => a > 0.5 ? 1 : 0);
                        car.control(action[0], action[1]);
                    }
                    else{
                        if(index == 0){
                            car.control(p.keyIsDown(39), p.keyIsDown(37));
                            if(car.alive == true)
                                trainingdataset.push({state: car.raydata, action: [p.keyIsDown(39), p.keyIsDown(37)]});
                        }   
                    }
                    car.render(p);
                });
            }

            /*p.keyPressed = () => {
                //Turn on car with up_arrow
                if(p.keyCode == 38)
                    p.car.on = !p.car.on  
                if(p.keyCode == 32){
                    p.car.autopilot.on = !p.car.autopilot.on;
                    if(p.car.autopilot.on == true){
                        p.car.on = false;
                        if(($("#skip-training").is(":checked") == false)){
                            const trainingfeatures = autopilotTrainingData.map(row => row.state);
                            const trainingclasses = autopilotTrainingData.map(row => row.action);                        
                            console.log(`training with ${autopilotTrainingData.length} records`)
                            p.car.autopilot.model.train(trainingfeatures, trainingclasses, 5000, 0.3, 40);                        
                            console.log(`training done`);
                            autopilotTrainingData = []; 
                        }
                        else{
                            p.car.autopilot.model.import(JSON.parse(localStorage.getItem("car-model")));
                        }
                        p.car.on = true;
                    }
                }
                if(p.keyCode == 82)
                    p.car.angle += p.PI;                    
            }*/
        }

        const environment = new p5(sketch, "environment");
    </script>
</body>
</html>